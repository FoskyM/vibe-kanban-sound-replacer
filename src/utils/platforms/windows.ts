// Windows 平台脚本生成器 / Windows platform script generator

import { SOUND_FILES, SOUND_FILENAMES, SoundFile } from '../../constants';
import { AudioFileInfo, PlatformScriptGenerator } from './types';

/**
 * Windows 平台脚本生成器 / Windows platform script generator
 */
export const windowsGenerator: PlatformScriptGenerator = {
  platform: 'windows',
  scriptFilename: 'toast-notification.ps1',

  generateScript(audioInfos: AudioFileInfo[]): string {
    // 生成配置对象 / Generate config object
    const configEntries = audioInfos.map(info => {
      const filesStr = info.sourceFiles.map(f => `"${f}"`).join(', ');
      const weightsStr = info.weights.join(', ');
      return `    "${info.targetFilename}" = @{
        Sources = @(${filesStr})
        Weights = @(${weightsStr})
        Mode = "${info.mode}"
    }`;
    }).join('\n');

    return `# Vibe Kanban Sound Replacer - Toast Notification Script (Windows)
# Generated by VKSR Plugin
# https://github.com/foskym/vibe-kanban-sound-replacer
#
# 工作原理 / How it works:
# 1. 脚本启动时扫描 sounds/ 目录下的音频源文件
# 2. 根据配置的模式选择一个音频文件
# 3. 将选中的音频复制为目标文件名 (如 sound-cow-mooing.wav)
# 4. Vibe Kanban 播放该文件时就会使用替换后的音频

param(
    [Parameter(Mandatory=$true)]
    [string]$Title,

    [Parameter(Mandatory=$true)]
    [string]$Message,

    [Parameter(Mandatory=$false)]
    [string]$AppName = "Vibe Kanban"
)

# ============================================
# Configuration
# ============================================
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$SoundsDir = Join-Path $ScriptDir "sounds"
$StateFile = Join-Path $ScriptDir "vksr-state.json"

# Sound configurations (generated from plugin settings)
# 每个音效的配置：Sources=源文件列表, Weights=权重, Mode=播放模式
$SoundConfig = @{
${configEntries}
}

# ============================================
# Functions
# ============================================

function Get-State {
    if (Test-Path $StateFile) {
        try {
            $content = Get-Content $StateFile -Raw -ErrorAction Stop
            if ($content) {
                return $content | ConvertFrom-Json
            }
        } catch {}
    }
    return [PSCustomObject]@{}
}

function Save-State($state) {
    try {
        $state | ConvertTo-Json | Set-Content $StateFile -Encoding UTF8 -ErrorAction Stop
    } catch {}
}

function Select-SourceFile($targetName, $cfg) {
    $sources = $cfg.Sources
    $weights = $cfg.Weights
    $mode = $cfg.Mode

    if ($sources.Count -eq 0) { return $null }
    if ($sources.Count -eq 1) { return $sources[0] }

    switch ($mode) {
        "single" {
            return $sources[0]
        }
        "random" {
            return $sources | Get-Random
        }
        "sequence" {
            $state = Get-State
            $key = "seq_$targetName"
            $index = 0
            if ($state.PSObject.Properties.Name -contains $key) {
                $index = [int]$state.$key
            }
            $selected = $sources[$index % $sources.Count]
            $state | Add-Member -NotePropertyName $key -NotePropertyValue (($index + 1) % $sources.Count) -Force
            Save-State $state
            return $selected
        }
        "weighted" {
            $totalWeight = ($weights | Measure-Object -Sum).Sum
            if ($totalWeight -le 0) { return $sources[0] }
            $rand = Get-Random -Minimum 0 -Maximum $totalWeight
            $cumulative = 0
            for ($i = 0; $i -lt $sources.Count; $i++) {
                $cumulative += $weights[$i]
                if ($rand -lt $cumulative) {
                    return $sources[$i]
                }
            }
            return $sources[0]
        }
        default {
            return $sources[0]
        }
    }
}

# ============================================
# Main Logic - Replace Sound Files
# ============================================

foreach ($targetName in $SoundConfig.Keys) {
    $cfg = $SoundConfig[$targetName]
    $targetPath = Join-Path $ScriptDir $targetName

    # 选择源文件 / Select source file
    $selectedSource = Select-SourceFile $targetName $cfg
    if (-not $selectedSource) { continue }

    $sourcePath = Join-Path $SoundsDir $selectedSource
    if (-not (Test-Path $sourcePath)) { continue }

    # 复制文件替换目标 / Copy file to replace target
    try {
        Copy-Item -Path $sourcePath -Destination $targetPath -Force -ErrorAction Stop
    } catch {
        # 忽略复制错误 / Ignore copy errors
    }
}

# ============================================
# Show Toast Notification
# ============================================

[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null
$Template = [Windows.UI.Notifications.ToastNotificationManager]::GetTemplateContent([Windows.UI.Notifications.ToastTemplateType]::ToastText02)
$RawXml = [xml] $Template.GetXml()
($RawXml.toast.visual.binding.text|where {\$_.id -eq "1"}).AppendChild($RawXml.CreateTextNode($Title)) | Out-Null
($RawXml.toast.visual.binding.text|where {\$_.id -eq "2"}).AppendChild($RawXml.CreateTextNode($Message)) | Out-Null
$SerializedXml = New-Object Windows.Data.Xml.Dom.XmlDocument
$SerializedXml.LoadXml($RawXml.OuterXml)
$Toast = [Windows.UI.Notifications.ToastNotification]::new($SerializedXml)
$Toast.Tag = $AppName
$Toast.Group = $AppName
$Notifier = [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier($AppName)
$Notifier.Show($Toast)
`;
  },

  generateReadme(): string {
    return `# Vibe Kanban Sound Replacer - Custom Notification Script

This package contains a customized toast notification script with your configured audio files.

**Platform: Windows**

## Installation

1. Extract this ZIP to a temporary location

2. Locate the Vibe Kanban utils directory:
   - Usually at: \`%LOCALAPPDATA%\\Programs\\vibe-kanban\\resources\\utils\\\`
   - Or check your Vibe Kanban installation directory under \`resources\\utils\\\`

3. **Backup** the original \`toast-notification.ps1\` (rename it to \`toast-notification.ps1.bak\`)

4. Copy all files from this package to the utils directory:
   - \`toast-notification.ps1\` (the new script)
   - \`sounds/\` folder (contains your audio source files)
   - \`sound-*.wav\` files (pre-placed audio files for immediate use)

## Directory Structure

After installation, your utils folder should look like:
\`\`\`
utils/
├── toast-notification.ps1      (the new script from this package)
├── toast-notification.ps1.bak  (your backup of the original)
├── sounds/                     (audio source files)
│   ├── sound-cow-mooing_0.wav
│   ├── sound-cow-mooing_1.wav
│   └── ...
├── sound-cow-mooing.wav        (pre-placed, will be replaced on each notification)
├── sound-rooster.wav           (pre-placed, will be replaced on each notification)
└── vksr-state.json             (auto-generated, stores sequence state)
\`\`\`

## How It Works

1. **First notification**: Uses the pre-placed audio files (e.g., \`sound-cow-mooing.wav\`)
2. **On each notification**: The script selects a new audio from \`sounds/\` based on your mode:
   - **Single**: Always uses the first audio file
   - **Random**: Randomly selects from the list
   - **Sequence**: Cycles through files in order
   - **Weighted**: Random selection weighted by your settings
3. The selected audio is copied to replace the target file for the **next** notification
4. This ensures smooth playback since Rust plays audio before the script runs

## Sound File Mapping

| Plugin Sound Name | Target File |
|-------------------|-------------|
${SOUND_FILES.map(name => `| ${name} | ${SOUND_FILENAMES[name as SoundFile]} |`).join('\n')}

## Troubleshooting

- **No sound change**: Check if files exist in the \`sounds/\` folder
- **Script error**: Ensure PowerShell execution policy allows scripts
  - Run: \`Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\`
- **Reset sequence**: Delete \`vksr-state.json\` to restart from the first file

## Notes

- Re-export from the plugin if you change your audio settings
- The script runs each time a notification is triggered
- All audio files are converted to WAV format for compatibility

---
Generated by VKSR Plugin
`;
  }
};
